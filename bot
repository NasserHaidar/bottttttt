import json
import asyncio
import os
from getpass import fallback_getpass
from importlib.metadata import entry_points
from tkinter.ttk import Button

import requests
import time
import logging

from warnings import filterwarnings
from telegram.warnings import PTBUserWarning
from telebot.types import CallbackQuery
from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup
import sqlite3
from telegram.ext import Application, CallbackQueryHandler, CommandHandler, MessageHandler,ConversationHandler,filters, ContextTypes , CallbackContext
from sqlalchemy import create_engine, Column, Integer, String, Text, DateTime
from sqlalchemy.orm import declarative_base, sessionmaker
from datetime import datetime

# Configure logging
logging.basicConfig(format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO)
logger = logging.getLogger(__name__)

# Leonardo API headers (replace with your API key)
LEONARDO_HEADERS = {
    "Authorization": "Bearer YOUR_LEONARDO_API_KEY",
    "Content-Type": "application/json"
}


filterwarnings(action="ignore", message=r".*CallbackQueryHandler", category=PTBUserWarning)


# SQLAlchemy setup
Base = declarative_base()
engine = create_engine("sqlite:///bot_database.db")  # SQLite database
Session = sessionmaker(bind=engine)
session = Session()

# Инициализация соединения с базой данных
conn = sqlite3.connect('bot_database.db', check_same_thread=False)  # Подставьте имя вашей базы данных
cursor = conn.cursor()

# Database models
class UserInteraction(Base):
    __tablename__ = "user_interactions"
    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(Integer, nullable=False)
    username = Column(String, nullable=True)
    prompt = Column(Text, nullable=False)
    generated_image_url = Column(Text, nullable=True)
    timestamp = Column(DateTime, default=datetime.utcnow)

# Create tables if not already present
Base.metadata.create_all(engine)

# Create tables if not present
cursor.execute("""
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY,
    username TEXT UNIQUE,
    balance REAL DEFAULT 0
)
""")
cursor.execute("""
CREATE TABLE IF NOT EXISTS user_interactions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    username TEXT,
    prompt TEXT,
    generated_image_url TEXT,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
)
""")
conn.commit()



# Function to send a photo with buttons
async def start_with_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user = update.effective_user

    # URL of the photo
    photo_url = "https://pixabay.com/photos/nave-altar-columns-rosette-7741260/"  # Replace with your desired photo URL

    # Create buttons
    keyboard = [
        [InlineKeyboardButton("Start", callback_data="start")],
        [InlineKeyboardButton("Help", callback_data="help")],
        [InlineKeyboardButton("Generate", callback_data="generate")],
        [InlineKeyboardButton("Profile", callback_data="profile")],
        [InlineKeyboardButton("Balance", callback_data="balance")],
    ]

    reply_markup = InlineKeyboardMarkup(keyboard)

    # Send photo with buttons
    await context.bot.send_photo(
        chat_id=update.effective_chat.id,
        photo=photo_url,
        caption=(
            "Welcome to the bot! We create and generate your avatars with Leonardo AI.\n"
            "Choose an option below:"
        ),
        reply_markup=reply_markup,
    )




# Define the start command
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Send a welcome message with inline buttons."""
    keyboard = [
        [InlineKeyboardButton("Help", callback_data="help")],
        [InlineKeyboardButton("Generate", callback_data="generate")],
        [InlineKeyboardButton("Profile", callback_data="profile")],
        [InlineKeyboardButton("Balance", callback_data="balance")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("Welcome to our bot! Choose an option:", reply_markup=reply_markup)

# Handle button interactions
async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle button clicks."""
    query = update.callback_query
    await query.answer()  # Acknowledge the button press

    if query.data == "help":
        await query.edit_message_text(
            "Here are some commands you can use:\n"
            "- Generate: Click to generate an image\n"
            "- Profile: View your profile\n"
            "- Balance: Check your balance"
        )
    elif query.data == "generate":
        await query.edit_message_text("Please type your prompt to generate an image.")
    elif query.data == "profile":
        await query.edit_message_text("Profile functionality coming soon.")
    elif query.data == "balance":
        await query.edit_message_text("Balance functionality coming soon.")
    else:
        await query.edit_message_text("Unknown action. Please try again.")



# Define a fallback for unrecognized messages
async def handle_unrecognized_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle text input that doesn't match commands."""
    await update.message.reply_text("I didn't understand that. Please use the buttons for navigation.")



async def cancel(update : Update , context : CallbackContext) -> None:
    await update.message.reply_text("operation cancelled.")
    return ConversationHandler.END



# Define the /profile command
async def profile(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # Define the custom keyboard
    keyboard = [
        ["/profile", "/balance"],
        ["/generate", "/help"]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    user = update.effective_user
    cursor.execute("SELECT * FROM users WHERE id=?", (user.id,))
    user_row = cursor.fetchone()

    if user_row:
        user_id, username, balance = user_row
        cursor.execute("SELECT generated_image_url, timestamp FROM user_interactions WHERE user_id=? ORDER BY timestamp DESC LIMIT 5", (user_id,))
        interactions = cursor.fetchall()

        message = f"User ID: {user_id}\nUsername: {username}\nBalance: {balance}\n\nRecent Images:"
        if interactions:
            for url, timestamp in interactions:
                message += f"\n- {timestamp}: {url}"
        else:
            message += "\nNo images generated yet."

        await update.message.reply_text(message , reply_markup=reply_markup)
    else:
        await update.message.reply_text("Profile not found. Use /start to register." , reply_markup=reply_markup)

# Define the /balance command
async def check_balance(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # Define the custom keyboard
    keyboard = [
        ["/profile", "/balance"],
        ["/generate", "/help"]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    user = update.effective_user
    cursor.execute("SELECT balance FROM users WHERE id=?", (user.id,))
    row = cursor.fetchone()
    if row:
        await update.message.reply_text(f"Your current balance is: {row[0]} credits." , reply_markup=reply_markup)
    else:
        await update.message.reply_text("You don't have an account yet. Use /start to register." , reply_markup=reply_markup)


#Define the /help command
async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # Define the custom keyboard
    keyboard = [
        ["/profile", "/balance"],
        ["/generate", "/help"]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    await update.message.reply_text("Available commands:\n"
                                    "/start - Start the bot\n"
                                    "/profile - Register or view your profile\n"
                                    "/balance - Check your current balance\n"
                                    "/generate - write what you want to generate",
                                    reply_markup=reply_markup)


async def generate(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user = update.effective_user

    try:
        # Check if the user provided a prompt
        if context.args:
            user_prompt = " ".join(context.args)
        else:
            await update.message.reply_text(
                "Please provide a prompt after /generate. Example:\n/generate a futuristic city at night")
            return

        # Acknowledge the prompt
        await update.message.reply_text(f"Received your prompt: {user_prompt}\nGenerating an image, please wait...")

        # Prepare the API payload
        payload = {
            "height": 512,
            "modelId": "6bef9f1b-29cb-40c7-b9df-32b51c1f67d3",  # Replace with your Leonardo model ID
            "prompt": user_prompt,
            "width": 512
        }

        # Call Leonardo API to start generation
        response = requests.post(
            "https://cloud.leonardo.ai/api/rest/v1/generations",
            json=payload,
            headers=LEONARDO_HEADERS
        )
        response.raise_for_status()

        # Extract generation ID
        generation_id = response.json()['sdGenerationJob']['generationId']

        # Wait for image generation to complete
        time.sleep(20)

        # Retrieve the generated image URL
        result_response = requests.get(
            f"https://cloud.leonardo.ai/api/rest/v1/generations/{generation_id}",
            headers=LEONARDO_HEADERS
        )
        result_response.raise_for_status()
        generated_image_url = result_response.json()['images'][0]['url']

        # Log the interaction in the database
        interaction = UserInteraction(
            user_id=user.id,
            username=user.username,
            prompt=user_prompt,
            generated_image_url=generated_image_url
        )
        session.add(interaction)
        session.commit()

        # Send the generated image back to the user
        await update.message.reply_photo(generated_image_url,
                                         caption=f"Here is your image based on the prompt: {user_prompt}")
    except Exception as e:
        logger.error(f"Error during image generation: {e}")
        await update.message.reply_text("An error occurred while generating the image. Please try again later.")



# Function to handle image uploads
async def handle_image(update: Update, context: CallbackContext) -> None:
    await update.message.reply_text("Image uploads are not supported in this version of the bot.")

async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_message = update.message.text.lower().strip()

    # Check if the user wants to generate an image
    if user_message.startswith("generate"):
        # Extract the prompt after the word "generate"
        user_prompt = user_message[len("generate"):].strip()

        if not user_prompt:
            await update.message.reply_text("Please provide a description of what you want to generate. Example:\ngenerate a futuristic city at night")
            return

        # Acknowledge and pass the request to the generate logic
        await update.message.reply_text(f"Received your prompt: {user_prompt}\nProcessing...")
        await process_generate_request(update, context, user_prompt)
    else:
        # Respond to other text inputs
        await update.message.reply_text("Unrecognized command or input. Use /help to see available commands.")


def main():
    """Run the bot."""
    application = Application.builder().token("7667227066:AAGy9ibE511zCBk_tKjhlaoNJFeX6whV6ds").build()

    # Add handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CallbackQueryHandler(button_handler))  # Handle button interactions
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_unrecognized_input))

    # Start the bot
    application.run_polling()


if __name__ == "__main__":
    main()
